"use strict";(self.webpackChunkroys_blog=self.webpackChunkroys_blog||[]).push([[1802],{3905:(n,e,t)=>{t.d(e,{Zo:()=>u,kt:()=>p});var o=t(7294);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}function c(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,o,r=function(n,e){if(null==n)return{};var t,o,r={},a=Object.keys(n);for(o=0;o<a.length;o++)t=a[o],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(o=0;o<a.length;o++)t=a[o],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var i=o.createContext({}),l=function(n){var e=o.useContext(i),t=e;return n&&(t="function"==typeof n?n(e):c(c({},e),n)),t},u=function(n){var e=l(n.components);return o.createElement(i.Provider,{value:e},n.children)},g={inlineCode:"code",wrapper:function(n){var e=n.children;return o.createElement(o.Fragment,{},e)}},d=o.forwardRef((function(n,e){var t=n.components,r=n.mdxType,a=n.originalType,i=n.parentName,u=s(n,["components","mdxType","originalType","parentName"]),d=l(t),p=r,m=d["".concat(i,".").concat(p)]||d[p]||g[p]||a;return t?o.createElement(m,c(c({ref:e},u),{},{components:t})):o.createElement(m,c({ref:e},u))}));function p(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var a=t.length,c=new Array(a);c[0]=d;var s={};for(var i in e)hasOwnProperty.call(e,i)&&(s[i]=e[i]);s.originalType=n,s.mdxType="string"==typeof n?n:r,c[1]=s;for(var l=2;l<a;l++)c[l]=t[l];return o.createElement.apply(null,c)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},3078:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>i,contentTitle:()=>c,default:()=>g,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var o=t(7462),r=(t(7294),t(3905));const a={id:"solana-Contract-exersize-5",title:"5\u3001\u8bfe\u540e\u7ec3\u4e60"},c=void 0,s={unversionedId:"solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1/solana-Contract-exersize-5",id:"solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1/solana-Contract-exersize-5",title:"5\u3001\u8bfe\u540e\u7ec3\u4e60",description:"\u8bfe\u540e\u7ec3\u4e60",source:"@site/docs/solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1/5\u3001\u8bfe\u540e\u7ec3\u4e60.md",sourceDirName:"solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1",slug:"/solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1/solana-Contract-exersize-5",permalink:"/docs/solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1/solana-Contract-exersize-5",draft:!1,editUrl:"https://github.com/iRoySwift/RoysBlog/tree/master/docs/solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1/5\u3001\u8bfe\u540e\u7ec3\u4e60.md",tags:[],version:"current",frontMatter:{id:"solana-Contract-exersize-5",title:"5\u3001\u8bfe\u540e\u7ec3\u4e60"},sidebar:"docs",previous:{title:"4\u3001Solana\u5408\u7ea6\u9519\u8bef\u5b9a\u4e49",permalink:"/docs/solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1/solana-Contract-error"},next:{title:"6\u3001Solana\u5408\u7ea6\u5f00\u53d1Part.2",permalink:"/docs/category/6solana\u5408\u7ea6\u5f00\u53d1part2"}},i={},l=[{value:"\u8bfe\u540e\u7ec3\u4e60",id:"\u8bfe\u540e\u7ec3\u4e60",level:2},{value:"\u53c2\u8003",id:"\u53c2\u8003",level:2}],u={toc:l};function g(n){let{components:e,...t}=n;return(0,r.kt)("wrapper",(0,o.Z)({},u,t,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"\u8bfe\u540e\u7ec3\u4e60"},"\u8bfe\u540e\u7ec3\u4e60"),(0,r.kt)("p",null,"\u5b9e\u73b0\u4e00\u4e2a\u5907\u5fd8\u5f55\u5408\u7ea6\u7a0b\u5e8f\u3002\u53ef\u4ee5\u5c06\u4e00\u6bb5\u5185\u5bb9\u5b58\u5165\u5230\u94fe\u4e0a\uff0c\u5e76\u53ef\u4ee5\u5bf9\u5176\u8fdb\u884c\u4fee\u6539\u3001\u5220\u9664\u3002"),(0,r.kt)("p",null,"\u63d0\u793a\uff1a"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u53c2\u8003 memo \u5408\u7ea6"),(0,r.kt)("li",{parentName:"ul"},"\u7ed9\u5b58\u50a8 Account \u8bbe\u7f6e\u6743\u9650\uff0c\u63a7\u5236\u8c01\u53ef\u4ee5\u4fee\u6539")),(0,r.kt)("h2",{id:"\u53c2\u8003"},"\u53c2\u8003"),(0,r.kt)("p",null,"\u5b9a\u4e49\u4e00\u4e2a state \u5b58\u50a8\u4fe1\u606f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rs",metastring:'title="hello-world-notebook/program/src/state.rs"',title:'"hello-world-notebook/program/src/state.rs"'},"use borsh::{BorshDeserialize, BorshSerialize};\n\n/// Define the type of state stored in accounts\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct GreetingAccount {\n    /// number of greetings\n    pub message: String,\n}\n\n")),(0,r.kt)("p",null,"\u5b9a\u4e49\u6307\u4ee4"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rs",metastring:'title="hello-world-notebook/program/src/instraction.rs"',title:'"hello-world-notebook/program/src/instraction.rs"'},"//! Program instruction\n\nuse borsh::{BorshDeserialize, BorshSchema, BorshSerialize};\n\n#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, PartialEq, BorshSchema)]\npub enum GreatingAccountInstruction {\n    Create(String),\n    Modify(String),\n    Delete,\n}\n\n")),(0,r.kt)("p",null,"\u521b\u5efa\u8bb0\u4e8b\u672c"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rs",metastring:'title="hello-world-notebook/program/src/processor.rs"',title:'"hello-world-notebook/program/src/processor.rs"'},'// Created\n    pub fn process_create(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        msg: String,\n    ) -> ProgramResult {\n        msg!("Created !");\n        // Iterating accounts is safer than indexing\n        let accounts_iter = &mut accounts.iter();\n\n        // Get the account to say hello to\n        let account = next_account_info(accounts_iter)?;\n\n        // The account must be owned by the program in order to modify its data\n        if account.owner != program_id {\n            msg!("Greeted account does not have the correct program id");\n            return Err(GreetingAccountError::NotOwnedByGreetingAccount.into());\n        }\n\n        msg!("account{:?}", &account,);\n        msg!("account_data={:?}", &account.data,);\n\n        // Increment and store the number of times the account has been greeted\n        let mut greeting_account = GreetingAccount {\n            message: "".to_string(),\n        };\n\n        greeting_account.message = msg;\n        greeting_account.serialize(&mut *account.data.borrow_mut())?;\n\n        msg!("Created: {:?}!", greeting_account.message);\n        Ok(())\n    }\n')),(0,r.kt)("p",null,"\u4fee\u6539\u5185\u5bb9"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rs"},'// Updated\n    pub fn process_modify(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        msg: String,\n    ) -> ProgramResult {\n        msg!("Modify !");\n        // Iterating accounts is safer than indexing\n        let accounts_iter = &mut accounts.iter();\n\n        // Get the account to say hello to\n        let account = next_account_info(accounts_iter)?;\n\n        // The account must be owned by the program in order to modify its data\n        if account.owner != program_id {\n            msg!("Greeted account does not have the correct program id");\n            return Err(GreetingAccountError::NotOwnedByGreetingAccount.into());\n        }\n\n        msg!("account: {:?}", &account,);\n        msg!("account_data: {:?}", &account.data,);\n\n        // Increment and store the number of times the account has been greeted\n        let mut greeting_account = GreetingAccount::try_from_slice(&account.data.borrow())?;\n        msg!("fetch create greeting_account value:{:?}", greeting_account);\n\n        // let mut greeting_account = GreetingAccount {\n        //     message: "".to_string(),\n        // };\n        greeting_account.message = msg;\n        greeting_account.serialize(&mut *account.data.borrow_mut())?;\n\n        msg!("Modify {:?}!", greeting_account.message);\n        Ok(())\n    }\n')),(0,r.kt)("p",null,"\u5220\u9664\u8d26\u53f7"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rs"},'// Deleted\n    pub fn process_delete(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n        // Iterating accounts is safer than indexing\n        let accounts_iter = &mut accounts.iter();\n\n        // Get the account to say hello to\n        let account = next_account_info(accounts_iter)?;\n        let greeting_account = next_account_info(accounts_iter)?;\n\n        // The account must be owned by the program in order to modify its data\n        if greeting_account.owner != program_id {\n            msg!("Greeted account does not have the correct program id");\n            return Err(GreetingAccountError::NotOwnedByGreetingAccount.into());\n        }\n\n        **account.try_borrow_mut_lamports()? += greeting_account.lamports();\n        **greeting_account.try_borrow_mut_lamports()? = 0;\n        Ok(())\n    }\n')),(0,r.kt)("p",null,"\u5ba2\u6237\u7aef\u4ee3\u7801"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="hello-world-notebook/ts/src/tests/Hello.test.ts"',title:'"hello-world-notebook/ts/src/tests/Hello.test.ts"'},'// No imports needed: web3, borsh, pg and more are globally available\n\nimport assert from "assert";\nimport * as borsh from "borsh";\nimport { Buffer } from "buffer";\n\nimport {\n    clusterApiUrl,\n    SystemProgram,\n    Connection,\n    Keypair,\n    PublicKey,\n    Transaction,\n    TransactionInstruction,\n    sendAndConfirmTransaction,\n    TransactionMessage,\n    VersionedTransaction,\n} from "@solana/web3.js";\nimport dotenv from "dotenv";\n\ndotenv.config();\n\nconst PROGRAM_ID = "9eMNGtayMEuNkzfdUYSw8k9msaPhFJG9Bi75wGQDvddR";\n\n// keypair\nconst secretKeyArray = JSON.parse(process.env.PRIVATE_KEY || "[]") as number[];\n\n// Step 1 \u8fde\u63a5\u5230Solana\u7f51\u7edc devnet\nconst devnet = clusterApiUrl("devnet");\nconst connection = new Connection(process.env.DEVNET || devnet, "confirmed");\n\n// Step 2 \u521b\u5efa\u8005\u8d26\u53f7\u4fe1\u606f\uff08private key\uff09\nconst signer = Keypair.fromSecretKey(new Uint8Array(secretKeyArray));\n\nconst pg = {\n    connection,\n    PROGRAM_ID: new PublicKey(PROGRAM_ID),\n    wallet: {\n        keypair: signer,\n        publicKey: signer.publicKey,\n    },\n};\n/**\n * The state of a greeting account managed by the hello world program\n */\nclass GreetingAccount {\n    message = "1234567890123456789";\n    constructor(fields: { message: string } | undefined = undefined) {\n        if (fields) {\n            this.message = fields.message;\n        }\n    }\n}\n\n/**\n * Borsh schema definition for greeting accounts\n */\nconst GreetingSchema = new Map([\n    [GreetingAccount, { kind: "struct", fields: [["message", "string"]] }],\n]);\n\n/**\n * The expected size of each greeting account.\n */\nconst GREETING_SIZE = borsh.serialize(\n    GreetingSchema as unknown as borsh.Schema,\n    new GreetingAccount()\n).length;\n\n// Instruction Variant indexes\nenum InstructionVariant {\n    Create = 0,\n    Modify = 1,\n    Delete = 2,\n}\n\nclass Assignable {\n    constructor(propertities) {\n        Object.keys(propertities).map(key => (this[key] = propertities[key]));\n    }\n}\n\n// Our instruction payload vocabulary\nclass CreateInstruction extends Assignable {}\nclass ModifyInstruction extends Assignable {}\nclass DeleteInstruction extends Assignable {}\n\n// Borsh needs a schema describing the payload\nconst GreetingAccountInstructionSchema = new Map([\n    [\n        CreateInstruction,\n        {\n            kind: "struct",\n            fields: [\n                ["id", "u8"],\n                ["msg", "string"],\n            ],\n        },\n    ],\n    [\n        ModifyInstruction,\n        {\n            kind: "struct",\n            fields: [\n                ["id", "u8"],\n                ["msg", "string"],\n            ],\n        },\n    ],\n    [\n        DeleteInstruction,\n        {\n            kind: "struct",\n            fields: [["id", "u8"]],\n        },\n    ],\n]);\ndescribe("Test", () => {\n    const greetingAccountKp = new Keypair();\n    it("Create", async () => {\n        console.log("\ud83d\ude80 ------------Create Start------------");\n        // \u53d1\u9001\u7684\u6570\u636e\n        const createdIx = new CreateInstruction({\n            id: InstructionVariant.Create,\n            msg: "abc",\n        });\n\n        //serialize the payload\n        const createSerBuf = Buffer.from(\n            borsh.serialize(GreetingAccountInstructionSchema, createdIx)\n        );\n        console.log("buffer:", createSerBuf);\n        // Create greetings account instruction\n        const lamports = await pg.connection.getMinimumBalanceForRentExemption(\n            GREETING_SIZE\n        );\n\n        const createGreetingAccountIx = SystemProgram.createAccount({\n            fromPubkey: pg.wallet.publicKey,\n            lamports,\n            newAccountPubkey: greetingAccountKp.publicKey,\n            programId: pg.PROGRAM_ID,\n            space: GREETING_SIZE,\n        });\n\n        // Create greet instruction\n        const greetIx = new TransactionInstruction({\n            // 1. The public keys of all the accounts the instruction will read/write\n            keys: [\n                {\n                    pubkey: greetingAccountKp.publicKey,\n                    isSigner: false,\n                    isWritable: true,\n                },\n            ],\n\n            // 2. The ID of the program this instruction will be sent to\n            programId: pg.PROGRAM_ID,\n\n            // 3. Data - in this case, there\'s none!\n            data: createSerBuf,\n        });\n\n        // Create transaction and add the instructions\n        const tx = new Transaction();\n        tx.add(createGreetingAccountIx, greetIx);\n\n        // Send and confirm the transaction\n        const txHash = await sendAndConfirmTransaction(pg.connection, tx, [\n            pg.wallet.keypair,\n            greetingAccountKp,\n        ]);\n        console.log(`\ud83c\udf89 Use \'solana confirm -v ${txHash}\' to see the logs`);\n\n        // Fetch the greetings account\n        const greetingAccount = await pg.connection.getAccountInfo(\n            greetingAccountKp.publicKey\n        );\n\n        if (!greetingAccount) {\n            console.error("Don\'t get greeting information");\n            return;\n        }\n\n        console.log("data:", greetingAccount.data);\n\n        // Deserialize the account data\n        const deserializedAccountData: any = borsh.deserialize(\n            GreetingSchema,\n            GreetingAccount,\n            greetingAccount.data.slice(0, 7)\n        );\n\n        // Assertions\n        expect(greetingAccount?.lamports).toEqual(lamports);\n        assert.equal(greetingAccount?.lamports, lamports);\n        assert(greetingAccount?.owner.equals(pg.PROGRAM_ID));\n        assert.deepEqual(\n            greetingAccount.data.slice(0, 7),\n            Buffer.from([3, 0, 0, 0, 97, 98, 99])\n        );\n        expect(greetingAccount.data.slice(0, 7)).toEqual(\n            Buffer.from([3, 0, 0, 0, 97, 98, 99])\n        );\n        assert.equal(deserializedAccountData?.message, "abc");\n        console.log("\ud83d\ude80 ------------Create End------------");\n    }, 200000);\n    it("Modify", async () => {\n        console.log("\ud83d\ude80 ------------Modify Start------------");\n        // \u53d1\u9001\u7684\u6570\u636e\n        const modifyIx = new ModifyInstruction({\n            id: InstructionVariant.Modify,\n            msg: "hello world!",\n        });\n\n        //serialize the payload\n        const modifySerBuf = Buffer.from(\n            borsh.serialize(GreetingAccountInstructionSchema, modifyIx)\n        );\n        console.log("buffer:", modifySerBuf);\n\n        // Create greet instruction\n        const greetIx = new TransactionInstruction({\n            // 1. The public keys of all the accounts the instruction will read/write\n            keys: [\n                {\n                    pubkey: greetingAccountKp.publicKey,\n                    isSigner: false,\n                    isWritable: true,\n                },\n            ],\n\n            // 2. The ID of the program this instruction will be sent to\n            programId: pg.PROGRAM_ID,\n\n            // 3. Data - in this case, there\'s none!\n            data: modifySerBuf,\n        });\n\n        // Create transaction and add the instructions\n        const tx = new Transaction();\n        tx.add(greetIx);\n\n        // Send and confirm the transaction\n        const txHash = await sendAndConfirmTransaction(pg.connection, tx, [\n            pg.wallet.keypair,\n        ]);\n        console.log(`\ud83c\udf89 Use \'solana confirm -v ${txHash}\' to see the logs`);\n\n        // Fetch the greetings account\n        const greetingAccount = await pg.connection.getAccountInfo(\n            greetingAccountKp.publicKey\n        );\n\n        if (!greetingAccount) {\n            console.error("Don\'t get greeting information");\n            return;\n        }\n\n        console.log("data:", greetingAccount.data);\n\n        // Deserialize the account data\n        const deserializedAccountData: any = borsh.deserialize(\n            GreetingSchema,\n            GreetingAccount,\n            greetingAccount.data.slice(0, 16)\n        );\n\n        // Assertions\n        // assert.equal(greetingAccount?.lamports, lamports);\n        assert(greetingAccount?.owner.equals(pg.PROGRAM_ID));\n        assert.deepEqual(\n            greetingAccount.data.slice(0, 16),\n            Buffer.from([\n                12, 0, 0, 0, 104, 101, 108, 108, 111, 32, 119, 111, 114, 108,\n                100, 33,\n            ])\n        );\n        assert.equal(deserializedAccountData?.message, "hello world!");\n        console.log("\ud83d\ude80 ------------Modify End------------");\n    }, 200000);\n    it("Delete", async () => {\n        console.log("\ud83d\ude80 ------------Delete Start------------");\n        const deleteIx = new DeleteInstruction({\n            id: InstructionVariant.Delete,\n        });\n        //serialize the payload\n        const deleteSerBuf = Buffer.from(\n            borsh.serialize(GreetingAccountInstructionSchema, deleteIx)\n        );\n        console.log("buffer: " + deleteSerBuf);\n        let txInstructions: TransactionInstruction[] = [];\n        txInstructions.push(\n            new TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: pg.wallet.keypair.publicKey,\n                        isSigner: true,\n                        isWritable: true,\n                    },\n                    {\n                        pubkey: greetingAccountKp.publicKey,\n                        isSigner: true,\n                        isWritable: true,\n                    },\n                ],\n                programId: pg.PROGRAM_ID,\n                data: deleteSerBuf,\n            })\n        );\n        // * Step 1 - Fetch Latest Blockhash\n        const {\n            context: { slot: minContextSlot },\n            value: { blockhash, lastValidBlockHeight },\n        } = await connection.getLatestBlockhashAndContext();\n        console.log(\n            "   \u2705 - 1. Fetched latest blockhash. Last valid height:",\n            lastValidBlockHeight\n        );\n        const messageV0 = new TransactionMessage({\n            payerKey: signer.publicKey,\n            recentBlockhash: blockhash,\n            instructions: txInstructions,\n        }).compileToV0Message();\n        console.log("   \u2705 - 2. Compiled transaction message");\n        const transaction = new VersionedTransaction(messageV0);\n\n        // * Step 3 - Sign your transaction with the required `Signers`\n        transaction.sign([pg.wallet.keypair, greetingAccountKp]);\n        console.log("   \u2705 - 3. Transaction Signed");\n\n        // * Step 4 - Send our v0 transaction to the cluster\n        const txid = await connection.sendTransaction(transaction, {\n            maxRetries: 5,\n            minContextSlot,\n        });\n        console.log("   \u2705 - 4. Transaction sent to network");\n\n        // * Step 5 - Confirm Transaction\n        const confirmation = await connection.confirmTransaction({\n            signature: txid,\n            blockhash: blockhash,\n            lastValidBlockHeight,\n        });\n        if (confirmation.value.err) {\n            throw new Error("   \u274c - 5. Transaction not confirmed.");\n        }\n\n        console.log(`\ud83c\udf89 Use \'solana confirm -v ${txid}\' to see the logs`);\n\n        // Fetch the greetings account\n        const greetingAccount = await pg.connection.getAccountInfo(\n            greetingAccountKp.publicKey\n        );\n\n        // Assertions\n        expect(greetingAccount).toBeNull();\n        console.log("\ud83d\ude80 ------------Delete End------------");\n    });\n});\n')))}g.isMDXComponent=!0}}]);