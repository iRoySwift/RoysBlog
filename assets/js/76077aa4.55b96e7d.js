"use strict";(self.webpackChunkroys_blog=self.webpackChunkroys_blog||[]).push([[1802],{7048:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>i,contentTitle:()=>c,default:()=>g,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var o=t(1527),r=t(7279);const a={id:"solana-Contract-exersize-5",title:"5\u3001\u8bfe\u540e\u7ec3\u4e60"},c=void 0,s={id:"solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1/solana-Contract-exersize-5",title:"5\u3001\u8bfe\u540e\u7ec3\u4e60",description:"\u8bfe\u540e\u7ec3\u4e60",source:"@site/docs/solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1/5\u3001\u8bfe\u540e\u7ec3\u4e60.md",sourceDirName:"solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1",slug:"/solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1/solana-Contract-exersize-5",permalink:"/docs/solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1/solana-Contract-exersize-5",draft:!1,unlisted:!1,editUrl:"https://github.com/iRoySwift/RoysBlog/tree/master/docs/solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1/5\u3001\u8bfe\u540e\u7ec3\u4e60.md",tags:[],version:"current",frontMatter:{id:"solana-Contract-exersize-5",title:"5\u3001\u8bfe\u540e\u7ec3\u4e60"},sidebar:"docs",previous:{title:"4\u3001Solana\u5408\u7ea6\u9519\u8bef\u5b9a\u4e49",permalink:"/docs/solana/solana-bootcamp/5\u3001Solana\u5408\u7ea6\u5f00\u53d1Part1/solana-Contract-error"},next:{title:"6\u3001Solana\u5408\u7ea6\u5f00\u53d1Part.2",permalink:"/docs/category/6solana\u5408\u7ea6\u5f00\u53d1part2"}},i={},l=[{value:"\u8bfe\u540e\u7ec3\u4e60",id:"\u8bfe\u540e\u7ec3\u4e60",level:2},{value:"\u53c2\u8003",id:"\u53c2\u8003",level:2}];function u(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"\u8bfe\u540e\u7ec3\u4e60",children:"\u8bfe\u540e\u7ec3\u4e60"}),"\n",(0,o.jsx)(e.p,{children:"\u5b9e\u73b0\u4e00\u4e2a\u5907\u5fd8\u5f55\u5408\u7ea6\u7a0b\u5e8f\u3002\u53ef\u4ee5\u5c06\u4e00\u6bb5\u5185\u5bb9\u5b58\u5165\u5230\u94fe\u4e0a\uff0c\u5e76\u53ef\u4ee5\u5bf9\u5176\u8fdb\u884c\u4fee\u6539\u3001\u5220\u9664\u3002"}),"\n",(0,o.jsx)(e.p,{children:"\u63d0\u793a\uff1a"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"\u53c2\u8003 memo \u5408\u7ea6"}),"\n",(0,o.jsx)(e.li,{children:"\u7ed9\u5b58\u50a8 Account \u8bbe\u7f6e\u6743\u9650\uff0c\u63a7\u5236\u8c01\u53ef\u4ee5\u4fee\u6539"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"\u53c2\u8003",children:"\u53c2\u8003"}),"\n",(0,o.jsx)(e.p,{children:"\u5b9a\u4e49\u4e00\u4e2a state \u5b58\u50a8\u4fe1\u606f"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-rs",metastring:'title="hello-world-notebook/program/src/state.rs"',children:"use borsh::{BorshDeserialize, BorshSerialize};\n\n/// Define the type of state stored in accounts\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct GreetingAccount {\n    /// number of greetings\n    pub message: String,\n}\n\n"})}),"\n",(0,o.jsx)(e.p,{children:"\u5b9a\u4e49\u6307\u4ee4"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-rs",metastring:'title="hello-world-notebook/program/src/instraction.rs"',children:"//! Program instruction\n\nuse borsh::{BorshDeserialize, BorshSchema, BorshSerialize};\n\n#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, PartialEq, BorshSchema)]\npub enum GreatingAccountInstruction {\n    Create(String),\n    Modify(String),\n    Delete,\n}\n\n"})}),"\n",(0,o.jsx)(e.p,{children:"\u521b\u5efa\u8bb0\u4e8b\u672c"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-rs",metastring:'title="hello-world-notebook/program/src/processor.rs"',children:'// Created\n    pub fn process_create(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        msg: String,\n    ) -> ProgramResult {\n        msg!("Created !");\n        // Iterating accounts is safer than indexing\n        let accounts_iter = &mut accounts.iter();\n\n        // Get the account to say hello to\n        let account = next_account_info(accounts_iter)?;\n\n        // The account must be owned by the program in order to modify its data\n        if account.owner != program_id {\n            msg!("Greeted account does not have the correct program id");\n            return Err(GreetingAccountError::NotOwnedByGreetingAccount.into());\n        }\n\n        msg!("account{:?}", &account,);\n        msg!("account_data={:?}", &account.data,);\n\n        // Increment and store the number of times the account has been greeted\n        let mut greeting_account = GreetingAccount {\n            message: "".to_string(),\n        };\n\n        greeting_account.message = msg;\n        greeting_account.serialize(&mut *account.data.borrow_mut())?;\n\n        msg!("Created: {:?}!", greeting_account.message);\n        Ok(())\n    }\n'})}),"\n",(0,o.jsx)(e.p,{children:"\u4fee\u6539\u5185\u5bb9"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-rs",children:'// Updated\n    pub fn process_modify(\n        program_id: &Pubkey,\n        accounts: &[AccountInfo],\n        msg: String,\n    ) -> ProgramResult {\n        msg!("Modify !");\n        // Iterating accounts is safer than indexing\n        let accounts_iter = &mut accounts.iter();\n\n        // Get the account to say hello to\n        let account = next_account_info(accounts_iter)?;\n\n        // The account must be owned by the program in order to modify its data\n        if account.owner != program_id {\n            msg!("Greeted account does not have the correct program id");\n            return Err(GreetingAccountError::NotOwnedByGreetingAccount.into());\n        }\n\n        msg!("account: {:?}", &account,);\n        msg!("account_data: {:?}", &account.data,);\n\n        // Increment and store the number of times the account has been greeted\n        let mut greeting_account = GreetingAccount::try_from_slice(&account.data.borrow())?;\n        msg!("fetch create greeting_account value:{:?}", greeting_account);\n\n        // let mut greeting_account = GreetingAccount {\n        //     message: "".to_string(),\n        // };\n        greeting_account.message = msg;\n        greeting_account.serialize(&mut *account.data.borrow_mut())?;\n\n        msg!("Modify {:?}!", greeting_account.message);\n        Ok(())\n    }\n'})}),"\n",(0,o.jsx)(e.p,{children:"\u5220\u9664\u8d26\u53f7"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-rs",children:'// Deleted\n    pub fn process_delete(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n        // Iterating accounts is safer than indexing\n        let accounts_iter = &mut accounts.iter();\n\n        // Get the account to say hello to\n        let account = next_account_info(accounts_iter)?;\n        let greeting_account = next_account_info(accounts_iter)?;\n\n        // The account must be owned by the program in order to modify its data\n        if greeting_account.owner != program_id {\n            msg!("Greeted account does not have the correct program id");\n            return Err(GreetingAccountError::NotOwnedByGreetingAccount.into());\n        }\n\n        **account.try_borrow_mut_lamports()? += greeting_account.lamports();\n        **greeting_account.try_borrow_mut_lamports()? = 0;\n        Ok(())\n    }\n'})}),"\n",(0,o.jsx)(e.p,{children:"\u5ba2\u6237\u7aef\u4ee3\u7801"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",metastring:'title="hello-world-notebook/ts/src/tests/Hello.test.ts"',children:'// No imports needed: web3, borsh, pg and more are globally available\n\nimport assert from "assert";\nimport * as borsh from "borsh";\nimport { Buffer } from "buffer";\n\nimport {\n    clusterApiUrl,\n    SystemProgram,\n    Connection,\n    Keypair,\n    PublicKey,\n    Transaction,\n    TransactionInstruction,\n    sendAndConfirmTransaction,\n    TransactionMessage,\n    VersionedTransaction,\n} from "@solana/web3.js";\nimport dotenv from "dotenv";\n\ndotenv.config();\n\nconst PROGRAM_ID = "9eMNGtayMEuNkzfdUYSw8k9msaPhFJG9Bi75wGQDvddR";\n\n// keypair\nconst secretKeyArray = JSON.parse(process.env.PRIVATE_KEY || "[]") as number[];\n\n// Step 1 \u8fde\u63a5\u5230Solana\u7f51\u7edc devnet\nconst devnet = clusterApiUrl("devnet");\nconst connection = new Connection(process.env.DEVNET || devnet, "confirmed");\n\n// Step 2 \u521b\u5efa\u8005\u8d26\u53f7\u4fe1\u606f\uff08private key\uff09\nconst signer = Keypair.fromSecretKey(new Uint8Array(secretKeyArray));\n\nconst pg = {\n    connection,\n    PROGRAM_ID: new PublicKey(PROGRAM_ID),\n    wallet: {\n        keypair: signer,\n        publicKey: signer.publicKey,\n    },\n};\n/**\n * The state of a greeting account managed by the hello world program\n */\nclass GreetingAccount {\n    message = "1234567890123456789";\n    constructor(fields: { message: string } | undefined = undefined) {\n        if (fields) {\n            this.message = fields.message;\n        }\n    }\n}\n\n/**\n * Borsh schema definition for greeting accounts\n */\nconst GreetingSchema = new Map([\n    [GreetingAccount, { kind: "struct", fields: [["message", "string"]] }],\n]);\n\n/**\n * The expected size of each greeting account.\n */\nconst GREETING_SIZE = borsh.serialize(\n    GreetingSchema as unknown as borsh.Schema,\n    new GreetingAccount()\n).length;\n\n// Instruction Variant indexes\nenum InstructionVariant {\n    Create = 0,\n    Modify = 1,\n    Delete = 2,\n}\n\nclass Assignable {\n    constructor(propertities) {\n        Object.keys(propertities).map(key => (this[key] = propertities[key]));\n    }\n}\n\n// Our instruction payload vocabulary\nclass CreateInstruction extends Assignable {}\nclass ModifyInstruction extends Assignable {}\nclass DeleteInstruction extends Assignable {}\n\n// Borsh needs a schema describing the payload\nconst GreetingAccountInstructionSchema = new Map([\n    [\n        CreateInstruction,\n        {\n            kind: "struct",\n            fields: [\n                ["id", "u8"],\n                ["msg", "string"],\n            ],\n        },\n    ],\n    [\n        ModifyInstruction,\n        {\n            kind: "struct",\n            fields: [\n                ["id", "u8"],\n                ["msg", "string"],\n            ],\n        },\n    ],\n    [\n        DeleteInstruction,\n        {\n            kind: "struct",\n            fields: [["id", "u8"]],\n        },\n    ],\n]);\ndescribe("Test", () => {\n    const greetingAccountKp = new Keypair();\n    it("Create", async () => {\n        console.log("\ud83d\ude80 ------------Create Start------------");\n        // \u53d1\u9001\u7684\u6570\u636e\n        const createdIx = new CreateInstruction({\n            id: InstructionVariant.Create,\n            msg: "abc",\n        });\n\n        //serialize the payload\n        const createSerBuf = Buffer.from(\n            borsh.serialize(GreetingAccountInstructionSchema, createdIx)\n        );\n        console.log("buffer:", createSerBuf);\n        // Create greetings account instruction\n        const lamports = await pg.connection.getMinimumBalanceForRentExemption(\n            GREETING_SIZE\n        );\n\n        const createGreetingAccountIx = SystemProgram.createAccount({\n            fromPubkey: pg.wallet.publicKey,\n            lamports,\n            newAccountPubkey: greetingAccountKp.publicKey,\n            programId: pg.PROGRAM_ID,\n            space: GREETING_SIZE,\n        });\n\n        // Create greet instruction\n        const greetIx = new TransactionInstruction({\n            // 1. The public keys of all the accounts the instruction will read/write\n            keys: [\n                {\n                    pubkey: greetingAccountKp.publicKey,\n                    isSigner: false,\n                    isWritable: true,\n                },\n            ],\n\n            // 2. The ID of the program this instruction will be sent to\n            programId: pg.PROGRAM_ID,\n\n            // 3. Data - in this case, there\'s none!\n            data: createSerBuf,\n        });\n\n        // Create transaction and add the instructions\n        const tx = new Transaction();\n        tx.add(createGreetingAccountIx, greetIx);\n\n        // Send and confirm the transaction\n        const txHash = await sendAndConfirmTransaction(pg.connection, tx, [\n            pg.wallet.keypair,\n            greetingAccountKp,\n        ]);\n        console.log(`\ud83c\udf89 Use \'solana confirm -v ${txHash}\' to see the logs`);\n\n        // Fetch the greetings account\n        const greetingAccount = await pg.connection.getAccountInfo(\n            greetingAccountKp.publicKey\n        );\n\n        if (!greetingAccount) {\n            console.error("Don\'t get greeting information");\n            return;\n        }\n\n        console.log("data:", greetingAccount.data);\n\n        // Deserialize the account data\n        const deserializedAccountData: any = borsh.deserialize(\n            GreetingSchema,\n            GreetingAccount,\n            greetingAccount.data.slice(0, 7)\n        );\n\n        // Assertions\n        expect(greetingAccount?.lamports).toEqual(lamports);\n        assert.equal(greetingAccount?.lamports, lamports);\n        assert(greetingAccount?.owner.equals(pg.PROGRAM_ID));\n        assert.deepEqual(\n            greetingAccount.data.slice(0, 7),\n            Buffer.from([3, 0, 0, 0, 97, 98, 99])\n        );\n        expect(greetingAccount.data.slice(0, 7)).toEqual(\n            Buffer.from([3, 0, 0, 0, 97, 98, 99])\n        );\n        assert.equal(deserializedAccountData?.message, "abc");\n        console.log("\ud83d\ude80 ------------Create End------------");\n    }, 200000);\n    it("Modify", async () => {\n        console.log("\ud83d\ude80 ------------Modify Start------------");\n        // \u53d1\u9001\u7684\u6570\u636e\n        const modifyIx = new ModifyInstruction({\n            id: InstructionVariant.Modify,\n            msg: "hello world!",\n        });\n\n        //serialize the payload\n        const modifySerBuf = Buffer.from(\n            borsh.serialize(GreetingAccountInstructionSchema, modifyIx)\n        );\n        console.log("buffer:", modifySerBuf);\n\n        // Create greet instruction\n        const greetIx = new TransactionInstruction({\n            // 1. The public keys of all the accounts the instruction will read/write\n            keys: [\n                {\n                    pubkey: greetingAccountKp.publicKey,\n                    isSigner: false,\n                    isWritable: true,\n                },\n            ],\n\n            // 2. The ID of the program this instruction will be sent to\n            programId: pg.PROGRAM_ID,\n\n            // 3. Data - in this case, there\'s none!\n            data: modifySerBuf,\n        });\n\n        // Create transaction and add the instructions\n        const tx = new Transaction();\n        tx.add(greetIx);\n\n        // Send and confirm the transaction\n        const txHash = await sendAndConfirmTransaction(pg.connection, tx, [\n            pg.wallet.keypair,\n        ]);\n        console.log(`\ud83c\udf89 Use \'solana confirm -v ${txHash}\' to see the logs`);\n\n        // Fetch the greetings account\n        const greetingAccount = await pg.connection.getAccountInfo(\n            greetingAccountKp.publicKey\n        );\n\n        if (!greetingAccount) {\n            console.error("Don\'t get greeting information");\n            return;\n        }\n\n        console.log("data:", greetingAccount.data);\n\n        // Deserialize the account data\n        const deserializedAccountData: any = borsh.deserialize(\n            GreetingSchema,\n            GreetingAccount,\n            greetingAccount.data.slice(0, 16)\n        );\n\n        // Assertions\n        // assert.equal(greetingAccount?.lamports, lamports);\n        assert(greetingAccount?.owner.equals(pg.PROGRAM_ID));\n        assert.deepEqual(\n            greetingAccount.data.slice(0, 16),\n            Buffer.from([\n                12, 0, 0, 0, 104, 101, 108, 108, 111, 32, 119, 111, 114, 108,\n                100, 33,\n            ])\n        );\n        assert.equal(deserializedAccountData?.message, "hello world!");\n        console.log("\ud83d\ude80 ------------Modify End------------");\n    }, 200000);\n    it("Delete", async () => {\n        console.log("\ud83d\ude80 ------------Delete Start------------");\n        const deleteIx = new DeleteInstruction({\n            id: InstructionVariant.Delete,\n        });\n        //serialize the payload\n        const deleteSerBuf = Buffer.from(\n            borsh.serialize(GreetingAccountInstructionSchema, deleteIx)\n        );\n        console.log("buffer: " + deleteSerBuf);\n        let txInstructions: TransactionInstruction[] = [];\n        txInstructions.push(\n            new TransactionInstruction({\n                keys: [\n                    {\n                        pubkey: pg.wallet.keypair.publicKey,\n                        isSigner: true,\n                        isWritable: true,\n                    },\n                    {\n                        pubkey: greetingAccountKp.publicKey,\n                        isSigner: true,\n                        isWritable: true,\n                    },\n                ],\n                programId: pg.PROGRAM_ID,\n                data: deleteSerBuf,\n            })\n        );\n        // * Step 1 - Fetch Latest Blockhash\n        const {\n            context: { slot: minContextSlot },\n            value: { blockhash, lastValidBlockHeight },\n        } = await connection.getLatestBlockhashAndContext();\n        console.log(\n            "   \u2705 - 1. Fetched latest blockhash. Last valid height:",\n            lastValidBlockHeight\n        );\n        const messageV0 = new TransactionMessage({\n            payerKey: signer.publicKey,\n            recentBlockhash: blockhash,\n            instructions: txInstructions,\n        }).compileToV0Message();\n        console.log("   \u2705 - 2. Compiled transaction message");\n        const transaction = new VersionedTransaction(messageV0);\n\n        // * Step 3 - Sign your transaction with the required `Signers`\n        transaction.sign([pg.wallet.keypair, greetingAccountKp]);\n        console.log("   \u2705 - 3. Transaction Signed");\n\n        // * Step 4 - Send our v0 transaction to the cluster\n        const txid = await connection.sendTransaction(transaction, {\n            maxRetries: 5,\n            minContextSlot,\n        });\n        console.log("   \u2705 - 4. Transaction sent to network");\n\n        // * Step 5 - Confirm Transaction\n        const confirmation = await connection.confirmTransaction({\n            signature: txid,\n            blockhash: blockhash,\n            lastValidBlockHeight,\n        });\n        if (confirmation.value.err) {\n            throw new Error("   \u274c - 5. Transaction not confirmed.");\n        }\n\n        console.log(`\ud83c\udf89 Use \'solana confirm -v ${txid}\' to see the logs`);\n\n        // Fetch the greetings account\n        const greetingAccount = await pg.connection.getAccountInfo(\n            greetingAccountKp.publicKey\n        );\n\n        // Assertions\n        expect(greetingAccount).toBeNull();\n        console.log("\ud83d\ude80 ------------Delete End------------");\n    });\n});\n'})})]})}function g(n={}){const{wrapper:e}={...(0,r.a)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(u,{...n})}):u(n)}},7279:(n,e,t)=>{t.d(e,{Z:()=>s,a:()=>c});var o=t(959);const r={},a=o.createContext(r);function c(n){const e=o.useContext(a);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:c(n.components),o.createElement(a.Provider,{value:e},n.children)}}}]);